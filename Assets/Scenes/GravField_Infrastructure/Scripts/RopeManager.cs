using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.Linq;
using SplineMesh;

public class RopeManager : MonoBehaviour
{
    public Transform performerTransformRoot;
    public float generatorRopeThickness = 0.02f;    
    public float generatorSegmentLength = 0.04f;
    public float generatorInterval = 0.04f;
    public int generatorSegmentCount = 10;

    public float jointMass = 1;
    public float jointDrag = 0;
    public float jointSprint = 80;
    public float jointDamper = 50;

    public float segmentMass = 1;
    public float segmentDrag = 0;


    RoleManager roleManager;
    List<Performer> performerList = new List<Performer>();
    List<bool> ropeStateList = new List<bool>();

    void Awake()
    {
        roleManager = FindObjectOfType<RoleManager>();


        for (int i=0; i<performerTransformRoot.childCount; i++)
        {
            performerList.Add(performerTransformRoot.GetChild(i).GetComponent<Performer>());
            ropeStateList.Add(false);
        }
    }

    void Start()
    {
        UpdateAllRopeState();
    }

    void OnEnable()
    {
        roleManager.OnStartPerformingEvent.AddListener(OnStartPerforming);
        roleManager.OnStopPerformingEvent.AddListener(OnStopPerforming);
    }
    void OnDisable()
    {
        roleManager.OnStartPerformingEvent.RemoveListener(OnStartPerforming);
        roleManager.OnStopPerformingEvent.RemoveListener(OnStopPerforming);
    }


    // Problem!!!
    void OnStartPerforming(int index, ulong client_index)
    {
        UpdateAllRopeState();
    }

    void OnStopPerforming(int index, ulong client_index)
    {
        UpdateAllRopeState();
    }

    void UpdateAllRopeState()
    {
        SetRopeState(0, performerList[0].isPerforming.Value == true && performerList[1].isPerforming.Value == true);
        SetRopeState(1, performerList[0].isPerforming.Value == true && performerList[2].isPerforming.Value == true);
        SetRopeState(2, performerList[1].isPerforming.Value == true && performerList[2].isPerforming.Value == true);
    }

    void SetRopeState(int index, bool state)
    {
        //SetPathVisible(index, state);
        SetSplineMeshVisible(index, state);
    }

    #region Contex Menu
    [ContextMenu("HideAllPath")]
    void HideAllPath()
    {
        SetPathVisible(0, false);
        SetPathVisible(1, false);
        SetPathVisible(2, false);
    }
    [ContextMenu("ShowAllPath")]
    void ShowAllPath()
    {
        SetPathVisible(0, true);
        SetPathVisible(1, true);
        SetPathVisible(2, true);
    }
    #endregion

    void SetPathVisible(int index, bool visiable)
    {
        if (index < 0 || index >= transform.childCount) return;

        Transform root_transform =  transform.GetChild(index);

        Transform anchor_root = root_transform.Find("Anchors");
        MeshRenderer[] renderers = anchor_root.GetComponentsInChildren<MeshRenderer>();
        foreach (MeshRenderer renderer in renderers)
        {
            renderer.enabled = visiable;
        }

        Transform joint_root = root_transform.Find("Joints");
        renderers = joint_root.GetComponentsInChildren<MeshRenderer>();
        foreach (MeshRenderer renderer in renderers)
        {
            renderer.enabled = visiable;
        }

        Transform segment_root = root_transform.Find("Segments");
        renderers = segment_root.GetComponentsInChildren<MeshRenderer>();
        foreach (MeshRenderer renderer in renderers)
        {
            renderer.enabled = visiable;
        }
    }

    void SetSplineMeshVisible(int index, bool visible)
    {
        Transform root_transform = transform.GetChild(index).Find("generated by SplineMeshTiling");
        root_transform?.gameObject.SetActive(visible);
    }


    #region Generate Rope
    [ContextMenu("GenerateRopes")]
    void GenerateRopes()
    {
        //// Remove all ropes
        //var childList = transform.Cast<Transform>().ToList();
        //foreach (Transform childTransform in childList)
        //{
        //    Destroy(childTransform.gameObject);
        //}


        // Generate Ropes
        for (int i=0; i<performerTransformRoot.childCount; i++)
        {
            for(int k=i+1; k<performerTransformRoot.childCount; k++)
            {
                //
                GameObject rope_root = new GameObject("Rope" + i.ToString()+k.ToString());
                rope_root.transform.parent = transform;
                RopeEffect performer_rope = rope_root.AddComponent<RopeEffect>();
                performer_rope.performer1 = performerTransformRoot.GetChild(i);
                performer_rope.performer2 = performerTransformRoot.GetChild(k);
                AddSplineMeshComponent(rope_root);


                //
                GameObject anchor_root = new GameObject("Anchors");
                anchor_root.transform.parent = rope_root.transform;
                GameObject anchor0 = GenerateAnchor(anchor_root, 0, CalculateGameObjectPosition("anchor", 0));
                GameObject anchor1 = GenerateAnchor(anchor_root, 1, CalculateGameObjectPosition("anchor", 1));
                performer_rope.ropeCorner1 = anchor0.transform;
                performer_rope.ropeCorner2 = anchor1.transform;


                // 
                GameObject joint_root = new GameObject("Joints");
                joint_root.transform.parent = rope_root.transform;
                GameObject segment_root = new GameObject("Segments");
                segment_root.transform.parent = rope_root.transform;
                GameObject last_segment = anchor0;
                for (int m = 0; m < generatorSegmentCount; m++)
                {
                    GameObject segment = GenerateSegment(segment_root, m, CalculateGameObjectPosition("segment", m));
                    GameObject joint = GenerateJoint(joint_root, m, CalculateGameObjectPosition("joint", m), last_segment, segment);
                    last_segment = segment;

                    if(m == generatorSegmentCount - 1)
                    {
                        GameObject last_joint = GenerateJoint(joint_root, m+1, CalculateGameObjectPosition("joint", m+1), segment, anchor1);
                    }
                }
            }
        }
        
    }

    Vector3 CalculateGameObjectPosition(string type, int index)
    {
        
        if (type == "anchor")
        {
            return index == 0 ? Vector3.zero : new Vector3(generatorSegmentCount * generatorSegmentLength + (generatorSegmentCount + 1) * generatorRopeThickness + generatorInterval * generatorSegmentCount * 2 + generatorRopeThickness, 0, 0);
        }
        else if(type == "segment")
        {
            return new Vector3(generatorRopeThickness * 0.5f + (index + 1) * generatorRopeThickness + index * generatorSegmentLength + generatorInterval * (index * 2 + 1) + 0.5f * generatorSegmentLength, 0, 0);
        }
        else if(type == "joint")
        {
            return new Vector3(generatorRopeThickness * 0.5f + index * generatorRopeThickness + index * generatorSegmentLength + generatorInterval * (index * 2)  + 0.5f * generatorRopeThickness, 0, 0);
        }

        return Vector3.zero;
    }

    GameObject GenerateAnchor(GameObject anchor_root, int index, Vector3 pos)
    {
        GameObject anchor = GameObject.CreatePrimitive(PrimitiveType.Cube);
        anchor.name = "Anchor" + index.ToString();
        anchor.transform.parent = anchor_root.transform;
        anchor.transform.position = pos;
        anchor.transform.localScale = Vector3.one * generatorRopeThickness;
        Rigidbody rigid_body = anchor.AddComponent<Rigidbody>();
        rigid_body.useGravity = false;
        rigid_body.isKinematic = true;

        return anchor;
    }

    GameObject GenerateJoint(GameObject joint_root, int index, Vector3 pos, GameObject left, GameObject right)
    {
        GameObject joint = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        joint.name = "Joint" + index.ToString();
        joint.transform.parent = joint_root.transform;
        joint.transform.position = pos;
        joint.transform.localScale = Vector3.one * generatorRopeThickness;
        Rigidbody rigid_body = joint.AddComponent<Rigidbody>();
        rigid_body.mass = jointMass;
        rigid_body.drag = jointDrag;

        HingeJoint hinge_left = joint.AddComponent<HingeJoint>();
        HingeJoint hinge_right = joint.AddComponent<HingeJoint>();
        JointSpring spring_settings = new JointSpring();
        spring_settings.spring = jointSprint;
        spring_settings.damper = jointDamper;

        hinge_left.connectedBody = left.GetComponent<Rigidbody>();
        hinge_right.connectedBody = right.GetComponent<Rigidbody>();

        hinge_left.anchor = Vector3.zero;
        hinge_right.anchor = Vector3.zero;

        hinge_left.spring = spring_settings;
        hinge_right.spring = spring_settings;

        JointLimits limits_settings = new JointLimits();
        limits_settings.bounceMinVelocity = 0;
        hinge_left.useLimits = true;
        hinge_left.limits = limits_settings;
        hinge_right.useLimits = true;
        hinge_right.limits = limits_settings;


        return joint;
    }

    GameObject GenerateSegment(GameObject segment_root, int index, Vector3 pos)
    {
        GameObject segment = GameObject.CreatePrimitive(PrimitiveType.Capsule);
        segment.name = "Segment" + index.ToString();
        segment.transform.parent = segment_root.transform;
        segment.transform.position = pos;
        segment.transform.localScale = new Vector3(generatorRopeThickness, generatorSegmentLength * 0.5f, generatorRopeThickness); // Capsule : The Y-axis length is twice as long as the x-axis and z-axis by default
        segment.transform.localEulerAngles = new Vector3(0, 0, 90);
        Rigidbody rigid_body = segment.AddComponent<Rigidbody>();
        rigid_body.mass = segmentMass;
        rigid_body.drag = segmentDrag;

        segment.GetComponent<Collider>().enabled = false;

        return segment;
    }


    void AddSplineMeshComponent(GameObject go)
    {
        Spline spline = go.AddComponent<Spline>();

        SplineMeshTiling meshTilling = go.AddComponent<SplineMeshTiling>();

        SplineSmoother smoother = go.AddComponent<SplineSmoother>();

        meshTilling.rotation = new Vector3(0, 0, 90);
        meshTilling.scale = Vector3.one * 0.01f;

        meshTilling.generateCollider = false;
        meshTilling.updateInPlayMode = true;
        meshTilling.curveSpace = true;
        smoother.curvature = 0.4f;
    }
    #endregion    
}
