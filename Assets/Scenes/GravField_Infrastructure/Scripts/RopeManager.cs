using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.Linq;
using SplineMesh;
using UnityEngine.Events;

public class RopeManager : MonoBehaviour
{
    public Transform performerTransformRoot;
    public Mesh ropeMesh;
    public Material ropeMat;
    public float generatorRopeLength = 2f;
    public float generatorRopeThickness = 0.02f;    
    public float generatorSegmentLength = 0.04f;
    public float generatorInterval = 0.04f;
    public int generatorSegmentCount = 5;

    public float jointMass = 2;
    public float jointDrag = 0;
    public float jointAngularDrag = 1;
    public float jointSprint = 80;
    public float jointDamper = 50;

    public float segmentMass = 2;
    public float segmentDrag = 0;
    public float segmentAngularDrag = 1;

    public Vector3 ropeCornerOffset;

    


    RoleManager roleManager;
    List<Performer> performerList = new List<Performer>();
    List<bool> ropeStateList = new List<bool>();
    List<Transform> ropeTransformList = new List<Transform>();

    void Awake()
    {
        roleManager = FindObjectOfType<RoleManager>();


        for (int i=0; i<performerTransformRoot.childCount; i++)
        {
            performerList.Add(performerTransformRoot.GetChild(i).GetComponent<Performer>());
            ropeStateList.Add(false);
            ropeTransformList.Add(null);
        }

        Debug.Log("Distance between A and B:" + Vector3.Distance(performerList[0].transform.position, performerList[1].transform.position));
    }

    void Start()
    {
        UpdateAllRopeState();

        ParameterReceiver.Instance.RegisterOscReceiverFunction("/jointmass", new UnityAction<float>(OnReceive_JointMass));
        ParameterReceiver.Instance.RegisterOscReceiverFunction("/jointdrag", new UnityAction<float>(OnReceive_JointDrag));
        ParameterReceiver.Instance.RegisterOscReceiverFunction("/segmentmass", new UnityAction<float>(OnReceive_SegmentMass));
        ParameterReceiver.Instance.RegisterOscReceiverFunction("/segmentdrag", new UnityAction<float>(OnReceive_SegmentDrag));
        ParameterReceiver.Instance.RegisterOscReceiverFunction("/ropethickness", new UnityAction<float>(OnReceive_RopeThickness));
    }

    void Update()
    {
        //for (int k = 0; k < transform.childCount; k++)
        //{
        //    SplineExtrusion splineExtrusion = transform.GetChild(k).GetComponent<SplineExtrusion>();
        //    if (splineExtrusion != null)
        //    {
        //        Transform extrusion_root = transform.GetChild(k).Find("generated by SplineExtrusion");
        //        MeshCollider[] mesh_colliders = extrusion_root.GetComponentsInChildren<MeshCollider>();
        //        foreach (MeshCollider collider in mesh_colliders)
        //        {
        //            collider.enabled = false;
        //        }
        //    }
        //}

        //AutoResetConnectedAnchor();
    }

    void AutoResetConnectedAnchor()
    {
        for(int k=0; k<ropeStateList.Count; k++)
        {
            if (ropeStateList[k] == false)
                continue;

            Transform joint_root = transform.GetChild(k).Find("Joints");
            int joint_count = joint_root.childCount + 2;
            int segment_count = joint_count - 1;

            Transform anchor_root = transform.GetChild(k).Find("Anchors");
            Transform start_anchor = anchor_root.GetChild(0);
            Transform end_anchor = anchor_root.GetChild(1);

            Vector3 start_pos = start_anchor.position;
            Vector3 end_pos = end_anchor.position;
            Vector3 dis_vec = end_pos - start_pos;
            Vector3 dis_unit = dis_vec / segment_count;
            Debug.Log("Dis / joint count = " + dis_vec / joint_count);
            Debug.Log("Dis / segment count = " + dis_vec / segment_count);


            start_anchor.GetComponent<HingeJoint>().connectedAnchor = Vector3.Scale(dis_unit * 0.5f, new Vector3(1.0f / start_anchor.localScale.x, 1.0f / start_anchor.localScale.y, 1.0f / start_anchor.localScale.z));
            end_anchor.GetComponent<HingeJoint>().connectedAnchor = -Vector3.Scale(dis_unit * 0.5f, new Vector3(1.0f / end_anchor.localScale.x, 1.0f / end_anchor.localScale.y, 1.0f / end_anchor.localScale.z));
            for (int i = 0; i < joint_root.childCount; i++)
            {
                Transform joint = joint_root.GetChild(i);
                HingeJoint[] hinges = joint.GetComponents<HingeJoint>();

                HingeJoint hinge = hinges[0];
                hinge.autoConfigureConnectedAnchor = false;
                hinge.autoConfigureConnectedAnchor = true;
                //hinge.connectedAnchor = Vector3.Scale(dis_unit * 0.5f, new Vector3(1.0f/joint.localScale.x, 1.0f / joint.localScale.y, 1.0f / joint.localScale.z));

                hinge = hinges[1];
                hinge.autoConfigureConnectedAnchor = false;
                hinge.autoConfigureConnectedAnchor = true;
                //hinge.connectedAnchor = -Vector3.Scale(dis_unit * 0.5f, new Vector3(1.0f / joint.localScale.x, 1.0f / joint.localScale.y, 1.0f / joint.localScale.z));
            }
        }
        
    }

    void OnEnable()
    {
        roleManager.OnStartPerformingEvent.AddListener(OnStartPerforming);
        roleManager.OnStopPerformingEvent.AddListener(OnStopPerforming);
    }
    void OnDisable()
    {
        roleManager.OnStartPerformingEvent.RemoveListener(OnStartPerforming);
        roleManager.OnStopPerformingEvent.RemoveListener(OnStopPerforming);
    }



    void OnStartPerforming(int index, ulong client_index)
    {
        UpdateAllRopeState();
    }

    void OnStopPerforming(int index, ulong client_index)
    {
        UpdateAllRopeState();
    }

    void UpdateAllRopeState()
    {
        SetRopeState(0, performerList[0].isPerforming.Value == true && performerList[1].isPerforming.Value == true);
        SetRopeState(1, performerList[0].isPerforming.Value == true && performerList[2].isPerforming.Value == true);
        SetRopeState(2, performerList[1].isPerforming.Value == true && performerList[2].isPerforming.Value == true);

        for (int i = 0; i < ropeStateList.Count; i++)
        {
            bool cur_rope_state = GetRopeState(i);
            // Just active rope, generate a new one
            if (cur_rope_state == true && ropeStateList[i] == false)
            {
                //GameObject rope = GenerateRope(i);
                //ropeTransformList[i] = rope.transform;
            }
            if (cur_rope_state == false && ropeStateList[i] == true)
            {
                //if (ropeTransformList[i] != null)
                //{
                //    Destroy(ropeTransformList[i].gameObject);
                //    ropeTransformList[i] = null;
                //}
            }
            ropeStateList[i] = cur_rope_state;
        }
    }

    bool GetRopeState(int rope_index)
    {
        Vector2Int performer_index = GetPerformerIndexOfRope(rope_index);
        return performerList[performer_index.x].isPerforming.Value == true && performerList[performer_index.y].isPerforming.Value == true;
    }

    Vector2Int GetPerformerIndexOfRope(int rope_index)
    {
        // Rope 0: Performer 0 , 1
        // Rope 1: Performer 0 , 2
        // Rope 2: Performer 1 , 2
        int start_index = rope_index == 2 ? 1 : 0;
        int end_index = rope_index == 0 ? 1 : 2;
        return new Vector2Int(start_index, end_index);
    }

    void SetRopeState(int index, bool state)
    {
        //SetPathVisible(index, state);
        SetSplineMeshVisible(index, state);
    }

    #region Contex Menu
    [ContextMenu("HideAllPath")]
    void HideAllPath()
    {
        SetPathVisible(0, false);
        SetPathVisible(1, false);
        SetPathVisible(2, false);
    }
    [ContextMenu("ShowAllPath")]
    void ShowAllPath()
    {
        SetPathVisible(0, true);
        SetPathVisible(1, true);
        SetPathVisible(2, true);
    }
    #endregion

    void SetPathVisible(int index, bool visiable)
    {
        if (index < 0 || index >= transform.childCount) return;

        Transform root_transform =  transform.GetChild(index);

        Transform anchor_root = root_transform.Find("Anchors");
        MeshRenderer[] renderers = anchor_root.GetComponentsInChildren<MeshRenderer>();
        foreach (MeshRenderer renderer in renderers)
        {
            renderer.enabled = visiable;
        }

        Transform joint_root = root_transform.Find("Joints");
        renderers = joint_root.GetComponentsInChildren<MeshRenderer>();
        foreach (MeshRenderer renderer in renderers)
        {
            renderer.enabled = visiable;
        }

        Transform segment_root = root_transform.Find("Segments");
        renderers = segment_root.GetComponentsInChildren<MeshRenderer>();
        foreach (MeshRenderer renderer in renderers)
        {
            renderer.enabled = visiable;
        }
    }

    void SetSplineMeshVisible(int index, bool visible)
    {
        Transform root_transform = transform.GetChild(index).Find("generated by SplineMeshTiling");
        root_transform?.gameObject.SetActive(visible);
    }


    #region Generate Rope
    [ContextMenu("GenerateRopes")]
    void GenerateRopes()
    {
        //// Remove all ropes
        var childList = transform.Cast<Transform>().ToList();
        foreach (Transform childTransform in childList)
        {
            DestroyImmediate(childTransform.gameObject);
        }


        // Generate Ropes
        for (int i=0; i<performerTransformRoot.childCount; i++)
        {
            GenerateRope(i);
        }
    }

    int CalculateDesiredSegmentCount(Vector3 start, Vector3 end)
    {
        float distance = Vector3.Distance(start, end);
        float src_min = 1;
        float src_max = 5;
        float dst_min = 3;
        float dst_max = 10;

        distance = Mathf.Clamp(distance, src_min, src_max);

        return Mathf.FloorToInt((distance - src_min) / (src_max - src_min) * (dst_max - dst_min) + dst_min);
    }

    Vector3 CalculateGameObjectPosition(string type, int index)
    {
        
        if (type == "anchor")
        {
            return index == 0 ? Vector3.zero : new Vector3(generatorSegmentCount * generatorSegmentLength + (generatorSegmentCount + 1) * generatorRopeThickness + generatorInterval * generatorSegmentCount * 2 + generatorRopeThickness, 0, 0);
        }
        else if(type == "segment")
        {
            return new Vector3(generatorRopeThickness * 0.5f + (index + 1) * generatorRopeThickness + index * generatorSegmentLength + generatorInterval * (index * 2 + 1) + 0.5f * generatorSegmentLength, 0, 0);
        }
        else if(type == "joint")
        {
            return new Vector3(generatorRopeThickness * 0.5f + index * generatorRopeThickness + index * generatorSegmentLength + generatorInterval * (index * 2)  + 0.5f * generatorRopeThickness, 0, 0);
        }

        return Vector3.zero;
    }

    GameObject GenerateRope(int rope_index)
    {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Anchor <- Joint -> Segment <- Joint -> Segment <- Joint -> Segment <- Joint -> Anchor
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // Generate Root
        Vector2Int performer_index = GetPerformerIndexOfRope(rope_index);
        GameObject rope_root = new GameObject("Rope" + performer_index.x.ToString() + performer_index.y.ToString());
        rope_root.transform.parent = transform;
        RopePath rope_path = rope_root.AddComponent<RopePath>();
        rope_path.performerStart = performerTransformRoot.GetChild(performer_index.x);
        rope_path.performerEnd = performerTransformRoot.GetChild(performer_index.y);
        rope_path.ropeOffset = ropeCornerOffset;
        Vector3 start_pos = Vector3.zero;
        Vector3 end_pos = new Vector3(generatorRopeLength, 0, 0);
        //Vector3 start_pos = rope_path.performerStart.position;
        //Vector3 end_pos = rope_path.performerEnd.position;


        // Generate Segments
        GameObject segment_root = new GameObject("Segments");
        segment_root.transform.parent = rope_root.transform;
        for (int m = 0; m < generatorSegmentCount; m++)
        {
            GenerateSegment(segment_root, m, Vector3.Lerp(start_pos, end_pos, (float)(m + 0.5f) / (float)generatorSegmentCount));            
        }

        // Generate Anchors
        GameObject anchor_root = new GameObject("Anchors");
        anchor_root.transform.parent = rope_root.transform;
        GameObject anchor0 = GenerateAnchor(anchor_root, 0, start_pos, segment_root.transform.GetChild(0));
        GameObject anchor1 = GenerateAnchor(anchor_root, 1, end_pos, segment_root.transform.GetChild(segment_root.transform.childCount-1));
        rope_path.ropeStart = anchor0.transform;
        rope_path.ropeEnd = anchor1.transform;


        // Generate Joints
        GameObject joint_root = new GameObject("Joints");
        joint_root.transform.parent = rope_root.transform;
        GameObject left_segment;
        GameObject right_segment;
        for (int m = 0; m < generatorSegmentCount + 1; m++)
        {
            left_segment = m == 0 ? anchor0 : segment_root.transform.GetChild(m-1).gameObject;
            right_segment = m == generatorSegmentCount ? anchor1 : segment_root.transform.GetChild(m).gameObject;
            
            GenerateJoint(joint_root, m, Vector3.Lerp(start_pos, end_pos, (float)(m) / (float)generatorSegmentCount), left_segment, right_segment);
        }


        // Add MeshSpline Components
        AddSplineMeshComponent(rope_root);

        return rope_root;

    }


    GameObject GenerateAnchor(GameObject anchor_root, int index, Vector3 pos, Transform connected_segment)
    {
        GameObject anchor = GameObject.CreatePrimitive(PrimitiveType.Cube);
        anchor.name = "Anchor" + index.ToString();
        anchor.transform.parent = anchor_root.transform;
        anchor.transform.position = pos;
        anchor.transform.localScale = Vector3.one * generatorRopeThickness;
        Rigidbody rigid_body = anchor.AddComponent<Rigidbody>();
        rigid_body.useGravity = false;

        ////////////////////////////////////////////////////////////
        // Caution!!!
        // RigidBody of anchros have to be Kinematic to avoid repelling connected joint while correctly influencing it        // 
        ////////////////////////////////////////////////////////////
        rigid_body.isKinematic = true; 

        rigid_body.constraints = RigidbodyConstraints.FreezePosition;
        rigid_body.mass = 100;


        //HingeJoint hinge = anchor.AddComponent<HingeJoint>();
        //SetHingeProperties(hinge, connected_segment.GetComponent<Rigidbody>());
        //hinge.autoConfigureConnectedAnchor = false;

        anchor.GetComponent<Collider>().enabled = false;
        //anchor.GetComponent<MeshRenderer>().enabled = false;

        return anchor;
    }

    GameObject GenerateJoint(GameObject joint_root, int index, Vector3 pos, GameObject left, GameObject right)
    {
        GameObject joint = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        joint.name = "Joint" + index.ToString();
        joint.transform.parent = joint_root.transform;
        joint.transform.position = pos;
        joint.transform.localScale = Vector3.one * generatorRopeThickness;
        Rigidbody rigid_body = joint.AddComponent<Rigidbody>();
        rigid_body.mass = jointMass;
        rigid_body.drag = jointDrag;
        rigid_body.angularDrag = jointAngularDrag;

        HingeJoint hinge_left = joint.AddComponent<HingeJoint>();
        HingeJoint hinge_right = joint.AddComponent<HingeJoint>();
        SetHingeProperties(hinge_left, left.GetComponent<Rigidbody>());
        SetHingeProperties(hinge_right, right.GetComponent<Rigidbody>());

        ////////////////////////////////////////////////////////////
        // Caution!!!
        // Collider of Joint can not be disabled otherwist it will lose elastcity
        ////////////////////////////////////////////////////////////
        joint.GetComponent<Collider>().enabled = true;

        //joint.GetComponent<MeshRenderer>().enabled = false;

        return joint;
    }

    void SetHingeProperties(HingeJoint hinge, Rigidbody rigid)
    {
        hinge.anchor = Vector3.zero;
        hinge.connectedBody = rigid;
        // When connected to anchor, there is no need to set calculate anchor position. just connect to (0,0,0)
        if (rigid.gameObject.name.Contains("Anchor"))
        {
            hinge.autoConfigureConnectedAnchor = false;
        }
        // When connected to another joint, the result highly depends on the initial position. so better generate rope on the groud
        else
        {
            hinge.autoConfigureConnectedAnchor = true;
        }

        hinge.useSpring = true;
        JointSpring spring_settings = new JointSpring();
        spring_settings.spring = jointSprint;
        spring_settings.damper = jointDamper;
        hinge.spring = spring_settings;

        JointLimits limits_settings = new JointLimits();
        limits_settings.bounceMinVelocity = 0;
        hinge.useLimits = true;
        hinge.limits = limits_settings;
        hinge.useLimits = true;
        hinge.limits = limits_settings;
    }

    GameObject GenerateSegment(GameObject segment_root, int index, Vector3 pos)
    {
        GameObject segment = GameObject.CreatePrimitive(PrimitiveType.Capsule);
        segment.name = "Segment" + index.ToString();
        segment.transform.parent = segment_root.transform;
        segment.transform.position = pos;
        segment.transform.localScale = new Vector3(generatorSegmentLength * 0.5f, generatorSegmentLength, generatorSegmentLength * 0.5f); // Capsule : The Y-axis length is twice as long as the x-axis and z-axis by default
        segment.transform.localEulerAngles = new Vector3(0, 0, 90);
        Rigidbody rigid_body = segment.AddComponent<Rigidbody>();
        rigid_body.mass = segmentMass;
        rigid_body.drag = segmentDrag;
        rigid_body.angularDrag = segmentAngularDrag;

        segment.GetComponent<Collider>().enabled = false;
        //segment.GetComponent<MeshRenderer>().enabled = false;

        return segment;
    }


    void AddSplineMeshComponent(GameObject go)
    {
        Spline spline = go.AddComponent<Spline>();

        SplineSmoother smoother = go.AddComponent<SplineSmoother>();
        smoother.curvature = 0.4f;

        SplineMeshTiling meshTilling = go.AddComponent<SplineMeshTiling>();
        meshTilling.mesh = ropeMesh;
        meshTilling.material = ropeMat;
        meshTilling.rotation = new Vector3(0, 0, 0);
        meshTilling.scale = Vector3.one * 0.1f;

        meshTilling.generateCollider = false;
        meshTilling.updateInPlayMode = true;
        meshTilling.curveSpace = false;
        
    }

    void SetRigidBody(string type, string param, float v)
    {

        for (int i = 0; i < transform.childCount; i++)
        {
            Transform root = transform.GetChild(i).Find(type);
            Rigidbody[] rigid_list = root.GetComponentsInChildren<Rigidbody>();
            foreach (Rigidbody rigid in rigid_list)
            {
                if (param == "mass") rigid.mass = v;
                else if (param == "drag") rigid.drag = v;
                else if (param == "angular") rigid.angularDrag = v;
            }
        }
    }

    void SetJoint(string param, float v)
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            Transform joint_root = transform.GetChild(i).Find("Joints");
            HingeJoint[] hinge_list = joint_root.GetComponentsInChildren<HingeJoint>();
            foreach (HingeJoint hinge in hinge_list)
            {
                JointSpring spring_settings = new JointSpring();
                spring_settings.spring = param == "spring" ? v : hinge.spring.spring;
                spring_settings.damper = param == "damper" ? v : hinge.spring.damper;
                hinge.spring = spring_settings;
            }
        }
    }
    

    void SetRopePathThickness(float v)
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            Transform segment_root = transform.GetChild(i).Find("Segments");
            for(int k= 0; k < segment_root.childCount; k++)
            {
                segment_root.GetChild(k).localScale = new Vector3(v, v * 2f, v);
            }

            Transform joint_root = transform.GetChild(i).Find("Joints");
            for (int k = 0; k < joint_root.childCount; k++)
            {
                joint_root.GetChild(k).localScale = new Vector3(v, v, v);
            }
        }
    }

    

    void OnReceive_JointMass(float v)
    {
        SetRigidBody("Joints", "mass", v);
    }
    void OnReceive_JointDrag(float v)
    {
        SetRigidBody("Joints", "drag", v);
    }
    void OnReceive_SegmentMass(float v)
    {
        SetRigidBody("Segments", "mass", v);
    }
    void OnReceive_SegmentDrag(float v)
    {
        SetRigidBody("Segments", "drag", v);
    }
    void OnReceive_RopeThickness(float v)
    {
        SetRopePathThickness(v);
    }


    [ContextMenu("GenerateExtrusionShape")]
    void GenerateExtrusionShape()
    {
        for(int k=0; k<transform.childCount; k++)
        {
            SplineExtrusion splineExtrusion = transform.GetChild(k).GetComponent<SplineExtrusion>();
            if (splineExtrusion != null)
            {
                int desired_count = 20;
                float desired_radius = 0.01f;
                List<ExtrusionSegment.Vertex> vertex_list = new List<ExtrusionSegment.Vertex>();
                for (int i = 0; i < desired_count; i++)
                {
                    float angle = (float)i / (float)desired_count * 360f;
                    Vector2 pos = new Vector2(desired_radius * Mathf.Sin(angle), desired_radius * Mathf.Cos(angle));
                    Vector2 nor = pos;

                    vertex_list.Add(new ExtrusionSegment.Vertex(pos, nor, 0));
                }
                splineExtrusion.shapeVertices.Clear();
                splineExtrusion.shapeVertices.AddRange(vertex_list);
            }
        }
    }

    
    #endregion


    public void SetAllDrag_UI(float v)
    {
        SetRigidBody("Joints", "drag", v);
        SetRigidBody("Segments", "drag", v);
    }

    public void SetAllMass_UI(float v)
    {
        SetRigidBody("Joints", "mass", v);
        SetRigidBody("Segments", "mass", v);
    }

    public void SetAllSpring_UI(float v)
    {
        SetJoint("spring", v);
    }

    public void SetAllDamper_UI(float v)
    {
        SetJoint("damper", v);
    }
    public void SetAllAngularDrag_UI(float v)
    {
        SetRigidBody("Joints", "angular", v);
        SetRigidBody("Segments", "angular", v);
    }

    public void SetAllThickness_UI(float v)
    {

    }
    public void SetJointDrag_UI(float v)
    {
        SetRigidBody("Joints", "drag", v);
    }

    public void SetSegmentDrag_UI(float v)
    {
        SetRigidBody("Segments", "drag", v);
    }

    public void SetJointMass_UI(float v)
    {
        SetRigidBody("Joints", "mass", v);
    }

    public void SetSegmentMass_UI(float v)
    {
        SetRigidBody("Segments", "mass", v);
    }
}
